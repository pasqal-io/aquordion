{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>Aquordion</code>","text":"<p><code>Aquordion</code> is a library to test and benchmark Pasqal's backends.</p>"},{"location":"#cross-backend-testing","title":"Cross-backend testing","text":"<p>Run the following to check correctness between backends:</p> <pre><code>hatch -e tests run test\n</code></pre>"},{"location":"#timing-benchmarks","title":"Timing benchmarks","text":"<p>Run the following command to generate timings:</p> <pre><code>hatch -e tests run benchmarks\n</code></pre>"},{"location":"benchmarks/","title":"Stats","text":"<p>We generate time stats using <code>pytest-benchmark</code> using \\(10\\) rounds for circuits A, B, C coming from  [^1]. So far, we benchmark between <code>PyQTorch</code> and <code>Horqrux</code>:</p> <ul> <li>the <code>run</code> method,</li> <li>the <code>expectation</code> method using a single observable Z,</li> <li>a variational quantum eigensolver[^2] (VQE) for the \\(H2\\) molecule in the STO-3G basis with a bondlength of \\(0.742 \\mathring{A}\\)[^3]. The underlying gradient-based Adam optimizer is run for \\(30\\) iterations.</li> </ul> <p>The current execution times are for circuits defined over \\(2, 5, 10, 15\\) qubits and \\(2, 5\\) layers for the <code>run</code> and <code>expectation</code> methods. For VQE, we reduce the tests to only \\(10\\) qubits for avoiding long jobs time on Github.</p> <pre><code>import json\nimport pandas as pd\nimport re\nimport matplotlib.pyplot as plt\n\nimport os.path\nfname = \"stats.json\"\nif not os.path.isfile(fname):\n    fname = \"docs/stats.json\"\nwith open(fname, 'r') as f:\n    data= json.load(f)['benchmarks']\n\ndata_stats = [{'name': x['name']} | x['params'] | x['stats'] for x in data]\n\nframe = pd.DataFrame(data_stats)\nframe['name'] = frame['name'].apply(lambda x: re.findall('test_(.*)\\\\[', x)[0])\nframe['fn_circuit'] = frame['benchmark_circuit'].apply(str)\nframe['fn_circuit'] = frame['fn_circuit'].apply(lambda x: re.findall('function (.*) at', x)[0])\n</code></pre>"},{"location":"benchmarks/#run-method","title":"Run method","text":"<p>Here are the median execution times for the <code>run</code> method over a random state.</p> <pre><code>run_frame = frame[frame['name'].str.startswith('run')]\nrun_frame['name'] = run_frame['name'].str.replace('run_', '')\n\naxes = run_frame.boxplot('median', by=['fn_circuit', 'name'])\naxes.set_title('Timing distributions by test and circuit')\naxes.set_xlabel('')\naxes.set_ylabel('Time (s)')\naxes.set_yscale('log')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-04-15T10:39:36.797276 image/svg+xml Matplotlib v3.10.1, https://matplotlib.org/"},{"location":"benchmarks/#expectation-method-z0-observable","title":"Expectation method: Z(0) observable","text":"<p>Here are the median execution times for the <code>expectation</code> method over a random state and the \\(Z(0)\\) observable.</p> <pre><code>expectation_frame = frame[frame['name'].str.startswith('expectation')]\nexpectation_frame['name'] = expectation_frame['name'].str.replace('expectation_', '')\naxes = expectation_frame.boxplot('median', by=['fn_circuit', 'name'])\naxes.set_title('Timing distributions by test and circuit')\naxes.set_xlabel('')\naxes.set_ylabel('Time (s)')\naxes.set_yscale('log')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-04-15T10:39:37.011638 image/svg+xml Matplotlib v3.10.1, https://matplotlib.org/"},{"location":"benchmarks/#vqe","title":"VQE","text":"<p>Here are the median execution times for VQE.</p> <pre><code>fname = \"stats_vqe.json\"\nif not os.path.isfile(fname):\n    fname = \"docs/stats_vqe.json\"\nwith open(fname, 'r') as f:\n    data_vqe = json.load(f)['benchmarks']\n\ndata_stats_vqe = [{'name': x['name']} | x['params'] | x['stats'] for x in data_vqe]\n\nframe_vqe = pd.DataFrame(data_stats_vqe)\nframe_vqe['name'] = frame_vqe['name'].apply(lambda x: re.findall('test_(.*)\\\\[', x)[0])\nframe_vqe['fn_circuit'] = frame_vqe['benchmark_vqe_ansatz'].apply(str)\nframe_vqe['fn_circuit'] = frame_vqe['fn_circuit'].apply(lambda x: re.findall('function (.*) at', x)[0])\nframe_vqe['name'] = frame_vqe['name'].str.replace('vqe_', '')\naxes = frame_vqe.boxplot('median', by=['fn_circuit', 'name'])\naxes.set_title('Timing distributions by test and circuit')\naxes.set_xlabel('')\naxes.set_ylabel('Time (s)')\naxes.set_yscale('log')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-04-15T10:39:37.209939 image/svg+xml Matplotlib v3.10.1, https://matplotlib.org/ <p>[^1]: Tyson Jones, Julien Gacon, Efficient calculation of gradients in classical simulations of variational quantum algorithms (2020) [^2]: Tilly et al., The Variational Quantum Eigensolver: a review of methods and best practices (2022) [^3]: Pennylane, Quantum Datasets</p>"}]}