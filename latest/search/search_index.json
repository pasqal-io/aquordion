{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>Aquordion</code>","text":"<p><code>Aquordion</code> is a library to test and benchmark Pasqal's backends.</p>"},{"location":"#cross-backend-testing","title":"Cross-backend testing","text":"<p>Run the following to check correctness between backends:</p> <pre><code>hatch -e tests run test\n</code></pre>"},{"location":"#timing-benchmarks","title":"Timing benchmarks","text":"<p>Run the following command to generate timings:</p> <pre><code>hatch -e tests run benchmarks\n</code></pre>"},{"location":"benchmarks/api/","title":"Stats","text":"<p>We generate timing statistics using <code>pytest-benchmark</code> using \\(R\\) rounds for circuits A, B, C <sup>1</sup>. In this section, we benchmark between <code>PyQTorch</code> and <code>Horqrux</code>:</p> <ul> <li>the <code>run</code> method,</li> <li>the <code>expectation</code> method using a single observable <code>Z</code>,</li> </ul> <p>The current execution times (with \\(R=10\\)) are for circuits defined over \\(2, 5, 10, 15\\) qubits and \\(2, 5\\) layers for the <code>run</code> and <code>expectation</code> methods.</p> <pre><code>import json\nimport pandas as pd\nimport re\nimport matplotlib.pyplot as plt\n\nimport os.path\nfname = \"stats.json\"\nif not os.path.isfile(fname):\n    fname = \"docs/stats.json\"\nwith open(fname, 'r') as f:\n    data= json.load(f)['benchmarks']\n\ndata_stats = [{'name': x['name']} | x['params'] | x['stats'] for x in data]\n\nframe = pd.DataFrame(data_stats)\nframe['name'] = frame['name'].apply(lambda x: re.findall('test_(.*)\\\\[', x)[0])\nframe['fn_circuit'] = frame['benchmark_circuit'].apply(str)\nframe['fn_circuit'] = frame['fn_circuit'].apply(lambda x: re.findall('function (.*) at', x)[0])\n</code></pre>"},{"location":"benchmarks/api/#run-method","title":"Run method","text":"<p>Here are the median execution times for the <code>run</code> method over a random state.</p> <pre><code>run_frame = frame[frame['name'].str.startswith('run')]\nrun_frame['name'] = run_frame['name'].str.replace('run_', '')\n\naxes = run_frame.boxplot('median', by=['fn_circuit', 'name'])\naxes.set_title(\"Timing distributions by test and circuit \\n for `run` method\")\naxes.set_xlabel('')\naxes.set_ylabel('Time (s)')\naxes.set_yscale('log')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-06-18T19:50:43.042965 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"benchmarks/api/#expectation-method-z0-observable","title":"Expectation method: Z(0) observable","text":"<p>Here are the median execution times for the <code>expectation</code> method over a random state and the \\(Z(0)\\) observable.</p> <pre><code>expectation_frame = frame[frame['name'].str.startswith('expectation')]\nexpectation_frame['name'] = expectation_frame['name'].str.replace('expectation_', '')\naxes = expectation_frame.boxplot('median', by=['fn_circuit', 'name'])\naxes.set_title(\"Timing distributions by test and circuit \\n for `expectation` method\")\naxes.set_xlabel('')\naxes.set_ylabel('Time (s)')\naxes.set_yscale('log')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-06-18T19:50:43.254521 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <ol> <li> <p>Tyson Jones, Julien Gacon, Efficient calculation of gradients in classical simulations of variational quantum algorithms (2020) \u21a9</p> </li> </ol>"},{"location":"benchmarks/dqc/","title":"Stats","text":"<p>In this section, we benchmark between backends to solve a partial differential equation using a Differential Quantum Circuit (DQC). The underlying ansatz is the hardware-efficient-ansatz. The underlying gradient-based Adam optimizer is run for \\(15\\) iterations. The example is taken from the <code>pyqtorch</code> and <code>horqrux</code> documentation. The circuits are defined over \\(4, 6\\) qubits \\(R=5\\) for avoiding long jobs time on Github.</p>"},{"location":"benchmarks/dqc/#differential-quantum-circuit","title":"Differential Quantum Circuit","text":"<p>Here are the median execution times for DQC. We compare optimizing with <code>PyQTorch</code> against optimizing with <code>Horqrux</code> and jitting.</p> <pre><code>fname = \"stats_dqc.json\"\n\nif not os.path.isfile(fname):\n    fname = \"docs/stats_dqc.json\"\nwith open(fname, 'r') as f:\n    data_vqe = json.load(f)['benchmarks']\n\n\ndata_stats_vqe = [{'name': x['name']} | x['params'] | x['stats'] for x in data_vqe]\n\nframe_vqe = pd.DataFrame(data_stats_vqe)\nframe_vqe['n_qubits'] = frame_vqe['name'].apply(lambda x: int(re.findall('n:(.*)\\\\D:', x)[0]))\nframe_vqe['name'] = frame_vqe['name'].apply(lambda x: re.findall('test_(.*)\\\\[', x)[0])\nframe_vqe['fn_circuit'] = frame_vqe['benchmark_dqc_ansatz'].apply(str)\nframe_vqe['fn_circuit'] = frame_vqe['fn_circuit'].apply(lambda x: re.findall('function (.*) at', x)[0])\nframe_vqe['name'] = frame_vqe['name'].str.replace('dqc_', '')\n\nnqubits = frame_vqe.n_qubits.unique()\n</code></pre>"},{"location":"benchmarks/dqc/#timings","title":"Timings","text":"<p>Below we present the distribution of median times for each number of qubits.</p> <pre><code>for nq in nqubits:\n    axes = frame_vqe[frame_vqe.n_qubits == nq].boxplot('median', by=['fn_circuit', 'name'])\n    axes.set_title(f\"Timing distributions - {nq} qubits\")\n    axes.set_xlabel('')\n    axes.set_ylabel('Time (s)')\n    plt.xticks(rotation=75)\n    plt.suptitle('')\n    plt.tight_layout()\n</code></pre> 2025-06-18T19:50:43.396650 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ 2025-06-18T19:50:43.476393 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"benchmarks/dqc/#speed-ups","title":"Speed-ups","text":"<pre><code>pyq_vqe = frame_vqe[frame_vqe.name == 'pyq'][['fn_circuit', 'median', 'n_qubits']]\nhorqrux_vqe = frame_vqe[frame_vqe.name == 'horqrux'][['fn_circuit', 'median', 'n_qubits']]\nratio_df = pd.merge(pyq_vqe, horqrux_vqe, on=['fn_circuit', 'n_qubits'], suffixes=['_pyq', '_horqrux'])\nratio_df['ratio'] = ratio_df['median_pyq'] / ratio_df['median_horqrux']\n\n\naxes = ratio_df.boxplot('ratio', by=['fn_circuit', 'n_qubits'])\naxes.set_title(f\"Speedup distributions by circuit and qubit number without shots\")\naxes.set_xlabel('')\naxes.set_ylabel('Speedup')\nplt.xticks(rotation=75)\nplt.suptitle('')\n</code></pre> 2025-06-18T19:50:43.535893 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"benchmarks/vqe/","title":"Stats","text":"<p>We generate timing statistics using <code>pytest-benchmark</code> using \\(R\\) rounds for circuits A, B, C <sup>1</sup> as ansatze for a variational quantum eigensolver task<sup>2</sup> (VQE) for the \\(H2\\) molecule in the STO-3G basis with a bondlength of \\(0.742 \\mathring{A}\\)<sup>3</sup>. The underlying gradient-based Adam optimizer is run for \\(50\\) iterations without shots and \\(10\\) when using shots. The circuits are defined over \\(4, 6\\) qubits \\(R=5\\) for avoiding long jobs time on Github. Additionally, we benchmark two differentiation modes (automatic differentiation and the Adjoint method <sup>1</sup>). Finally, we also performing shot-based benchmarks, we use \\(100\\) shots.</p> <p>Note we are disabling shots due to an issue.</p>"},{"location":"benchmarks/vqe/#variational-quantum-eigensolver","title":"Variational Quantum Eigensolver","text":"<p>Here are the median execution times for VQE. We compare optimizing with <code>PyQTorch</code> against optimizing with <code>Horqrux</code> and jitting.</p> <pre><code>import json\nimport pandas as pd\nimport re\nimport matplotlib.pyplot as plt\n\nimport os.path\n\nfname = \"stats_vqe_noshots.json\"\nfnameshots = \"stats_vqe_shots.json\"\n\nif not os.path.isfile(fname):\n    fname = \"docs/stats_vqe_noshots.json\"\n    fnameshots = \"docs/stats_vqe_shots.json\"\nwith open(fname, 'r') as f:\n    data_vqe = json.load(f)['benchmarks']\nwith open(fnameshots, 'r') as f:\n    data_vqeshots = json.load(f)['benchmarks']\n\ndata_stats_vqe = [{'name': x['name']} | x['params'] | x['stats'] for x in data_vqe]\ndata_stats_vqeshots = [{'name': x['name']} | x['params'] | x['stats'] for x in data_vqeshots]\n\nframe_vqe = pd.DataFrame(data_stats_vqe)\nframe_vqe['n_qubits'] = frame_vqe['name'].apply(lambda x: int(re.findall('n:(.*)\\\\D:', x)[0]))\nframe_vqe['name'] = frame_vqe['name'].apply(lambda x: re.findall('test_(.*)\\\\[', x)[0])\nframe_vqe['fn_circuit'] = frame_vqe['benchmark_vqe_ansatz'].apply(str)\nframe_vqe['fn_circuit'] = frame_vqe['fn_circuit'].apply(lambda x: re.findall('function (.*) at', x)[0])\nframe_vqe['name'] = frame_vqe['name'].str.replace('vqe_', '')\nframe_vqe['n_shots'] = 0\n\nframe_vqeshots = pd.DataFrame(data_stats_vqeshots)\nframe_vqeshots['n_qubits'] = frame_vqeshots['name'].apply(lambda x: int(re.findall('n:(.*)\\\\D:', x)[0]))\nframe_vqeshots['name'] = frame_vqeshots['name'].apply(lambda x: re.findall('test_(.*)\\\\[', x)[0])\nframe_vqeshots['fn_circuit'] = frame_vqeshots['benchmark_vqe_ansatz'].apply(str)\nframe_vqeshots['fn_circuit'] = frame_vqeshots['fn_circuit'].apply(lambda x: re.findall('function (.*) at', x)[0])\nframe_vqeshots['name'] = frame_vqeshots['name'].str.replace('vqe_', '')\nframe_vqeshots['diff_mode'] = 'ad'\nframe_vqeshots['n_shots'] = 100\n\nnqubits = frame_vqe.n_qubits.unique()\n</code></pre>"},{"location":"benchmarks/vqe/#timings","title":"Timings","text":"<p>Below we present the distribution of median times for each circuit type, with and without shots.</p> <pre><code>for nq in nqubits:\n    axes = frame_vqe[frame_vqe.n_qubits == nq].boxplot('median', by=['fn_circuit', 'name', 'diff_mode'])\n    axes.set_title(f\"Timing distributions by differentiation methods and circuit \\n without shots - 100 epochs - {nq} qubits\")\n    axes.set_xlabel('')\n    axes.set_ylabel('Time (s)')\n    plt.xticks(rotation=75)\n    plt.suptitle('')\n    plt.tight_layout()\n\n\n\n    axes = frame_vqeshots[frame_vqeshots.n_qubits == nq].boxplot('median', by=['fn_circuit', 'name'])\n    axes.set_title(f\"Timing distributions by differentiation methods and circuit \\n with shots - 50 epochs - {nq} qubits\")\n    axes.set_xlabel('')\n    axes.set_ylabel('Time (s)')\n    plt.xticks(rotation=75)\n    plt.suptitle('')\n    plt.tight_layout()\n</code></pre> 2025-06-18T19:50:43.714260 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ 2025-06-18T19:50:43.840415 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ 2025-06-18T19:50:43.983328 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ 2025-06-18T19:50:44.116475 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"benchmarks/vqe/#speed-ups","title":"Speed-ups","text":"<p>Below we present the distribution of median speed-ups for each circuit type. The timing ratio between <code>PyQTorch</code> (numerator) and <code>Horqrux</code> (denominator) executions is computed. A ratio higher than \\(1\\) means <code>Horqrux</code> and jitting provide computational speed-up over <code>PyQTorch</code>.</p> <pre><code>frame_vqe = pd.concat([frame_vqe, frame_vqeshots], ignore_index=True)\n\npyq_vqe = frame_vqe[frame_vqe.name == 'pyq'][['fn_circuit', 'median', 'n_shots', 'diff_mode', 'n_qubits']]\nhorqrux_vqe = frame_vqe[frame_vqe.name == 'horqrux'][['fn_circuit', 'median', 'n_shots', 'diff_mode', 'n_qubits']]\nratio_df = pd.merge(pyq_vqe, horqrux_vqe, on=['fn_circuit', 'diff_mode', 'n_shots', 'n_qubits'], suffixes=['_pyq', '_horqrux'])\nratio_df['ratio'] = ratio_df['median_pyq'] / ratio_df['median_horqrux']\n\n\naxes = ratio_df[ratio_df.n_shots == 0].boxplot('ratio', by=['fn_circuit', 'diff_mode', 'n_qubits'])\naxes.set_title(f\"Speedup distributions by circuit and qubit number without shots \\n 100 epochs \")\naxes.set_xlabel('')\naxes.set_ylabel('Speedup')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n\n\naxes = ratio_df[ratio_df.n_shots &gt; 0].boxplot('ratio', by=['fn_circuit', 'n_qubits'])\naxes.set_title(f\"Speedup distributions by circuit and qubit number with shots \\n 50 epochs\")\naxes.set_xlabel('')\naxes.set_ylabel('Speedup')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-06-18T19:50:44.324839 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ 2025-06-18T19:50:44.448317 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <ol> <li> <p>Tyson Jones, Julien Gacon, Efficient calculation of gradients in classical simulations of variational quantum algorithms (2020) \u21a9\u21a9</p> </li> <li> <p>Tilly et al., The Variational Quantum Eigensolver: a review of methods and best practices (2022) \u21a9</p> </li> <li> <p>Pennylane, Quantum Datasets \u21a9</p> </li> </ol>"}]}