{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>Aquordion</code>","text":"<p><code>Aquordion</code> is a library to test and benchmark Pasqal's backends.</p>"},{"location":"#cross-backend-testing","title":"Cross-backend testing","text":"<p>Run the following to check correctness between backends:</p> <pre><code>hatch -e tests run test\n</code></pre>"},{"location":"#timing-benchmarks","title":"Timing benchmarks","text":"<p>Run the following command to generate timings:</p> <pre><code>hatch -e tests run benchmarks\n</code></pre>"},{"location":"benchmarks/","title":"Stats","text":"<p>We generate timing statistics using <code>pytest-benchmark</code> using \\(R\\) rounds for circuits A, B, C <sup>1</sup>. So far, we benchmark between <code>PyQTorch</code> and <code>Horqrux</code>:</p> <ul> <li>the <code>run</code> method,</li> <li>the <code>expectation</code> method using a single observable Z,</li> <li>a variational quantum eigensolver<sup>2</sup> (VQE) for the \\(H2\\) molecule in the STO-3G basis with a bondlength of \\(0.742 \\mathring{A}\\)<sup>3</sup>. The underlying gradient-based Adam optimizer is run for \\(50\\) iterations.</li> </ul> <p>The current execution times (with \\(R=10\\)) are for circuits defined over \\(2, 5, 10, 15\\) qubits and \\(2, 5\\) layers for the <code>run</code> and <code>expectation</code> methods. For VQE, we reduce the tests to \\(4\\) qubits \\(R=5\\) for avoiding long jobs time on Github, and we also benchmark two differentiation modes (automatic differentiation and the Adjoint method <sup>1</sup>). Additionally, when using \\(100\\) shots, we reduce the number of iterations to \\(20\\).</p> <pre><code>import json\nimport pandas as pd\nimport re\nimport matplotlib.pyplot as plt\n\nimport os.path\nfname = \"stats.json\"\nif not os.path.isfile(fname):\n    fname = \"docs/stats.json\"\nwith open(fname, 'r') as f:\n    data= json.load(f)['benchmarks']\n\ndata_stats = [{'name': x['name']} | x['params'] | x['stats'] for x in data]\n\nframe = pd.DataFrame(data_stats)\nframe['name'] = frame['name'].apply(lambda x: re.findall('test_(.*)\\\\[', x)[0])\nframe['fn_circuit'] = frame['benchmark_circuit'].apply(str)\nframe['fn_circuit'] = frame['fn_circuit'].apply(lambda x: re.findall('function (.*) at', x)[0])\n</code></pre>"},{"location":"benchmarks/#run-method","title":"Run method","text":"<p>Here are the median execution times for the <code>run</code> method over a random state.</p> <pre><code>run_frame = frame[frame['name'].str.startswith('run')]\nrun_frame['name'] = run_frame['name'].str.replace('run_', '')\n\naxes = run_frame.boxplot('median', by=['fn_circuit', 'name'])\naxes.set_title(\"Timing distributions by test and circuit \\n for `run` method\")\naxes.set_xlabel('')\naxes.set_ylabel('Time (s)')\naxes.set_yscale('log')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-05-08T10:03:53.282783 image/svg+xml Matplotlib v3.10.1, https://matplotlib.org/"},{"location":"benchmarks/#expectation-method-z0-observable","title":"Expectation method: Z(0) observable","text":"<p>Here are the median execution times for the <code>expectation</code> method over a random state and the \\(Z(0)\\) observable.</p> <pre><code>expectation_frame = frame[frame['name'].str.startswith('expectation')]\nexpectation_frame['name'] = expectation_frame['name'].str.replace('expectation_', '')\naxes = expectation_frame.boxplot('median', by=['fn_circuit', 'name'])\naxes.set_title(\"Timing distributions by test and circuit \\n for `expectation` method\")\naxes.set_xlabel('')\naxes.set_ylabel('Time (s)')\naxes.set_yscale('log')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-05-08T10:03:53.496021 image/svg+xml Matplotlib v3.10.1, https://matplotlib.org/"},{"location":"benchmarks/#vqe","title":"VQE","text":"<p>Here are the median execution times for VQE. We compare optimizing with <code>PyQTorch</code> against optimizing with <code>Horqrux</code> and jitting.</p> <pre><code>fname = \"stats_vqe_noshots.json\"\nfnameshots = \"stats_vqe_shots.json\"\n\nif not os.path.isfile(fname):\n    fname = \"docs/stats_vqe_noshots.json\"\n    fnameshots = \"docs/stats_vqe_shots.json\"\nwith open(fname, 'r') as f:\n    data_vqe = json.load(f)['benchmarks']\nwith open(fnameshots, 'r') as f:\n    data_vqeshots = json.load(f)['benchmarks']\n\ndata_stats_vqe = [{'name': x['name']} | x['params'] | x['stats'] for x in data_vqe]\ndata_stats_vqeshots = [{'name': x['name']} | x['params'] | x['stats'] for x in data_vqeshots]\n\nframe_vqe = pd.DataFrame(data_stats_vqe)\nframe_vqe['name'] = frame_vqe['name'].apply(lambda x: re.findall('test_(.*)\\\\[', x)[0])\nframe_vqe['fn_circuit'] = frame_vqe['benchmark_vqe_ansatz'].apply(str)\nframe_vqe['fn_circuit'] = frame_vqe['fn_circuit'].apply(lambda x: re.findall('function (.*) at', x)[0])\nframe_vqe['name'] = frame_vqe['name'].str.replace('vqe_', '')\nframe_vqe['n_shots'] = 0\n\nframe_vqeshots = pd.DataFrame(data_stats_vqeshots)\nframe_vqeshots['name'] = frame_vqeshots['name'].apply(lambda x: re.findall('test_(.*)\\\\[', x)[0])\nframe_vqeshots['fn_circuit'] = frame_vqeshots['benchmark_vqe_ansatz'].apply(str)\nframe_vqeshots['fn_circuit'] = frame_vqeshots['fn_circuit'].apply(lambda x: re.findall('function (.*) at', x)[0])\nframe_vqeshots['name'] = frame_vqeshots['name'].str.replace('vqe_', '')\nframe_vqeshots['n_shots'] = 1000\nframe_vqeshots['diff_mode'] = 'ad'\n</code></pre>"},{"location":"benchmarks/#times","title":"Times","text":"<p>Below we present the distribution of median times for each circuit type, without shots and with shots (\\(n_shots = 1000\\)).</p> <pre><code>axes = frame_vqe.boxplot('median', by=['fn_circuit', 'name', 'diff_mode'])\naxes.set_title('Timing distributions by test and circuit without shots - 50 epochs')\naxes.set_xlabel('')\naxes.set_ylabel('Time (s)')\n#axes.set_yscale('log')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n\n\n\naxes = frame_vqeshots.boxplot('median', by=['fn_circuit', 'name'])\naxes.set_title('Timing distributions by test and circuit with shots  - 10 epochs')\naxes.set_xlabel('')\naxes.set_ylabel('Time (s)')\n#axes.set_yscale('log')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-05-08T10:03:53.686895 image/svg+xml Matplotlib v3.10.1, https://matplotlib.org/ 2025-05-08T10:03:53.815693 image/svg+xml Matplotlib v3.10.1, https://matplotlib.org/"},{"location":"benchmarks/#speed-ups","title":"Speed-ups","text":"<p>Below we present the distribution of median speed-ups for each circuit type. The timing ratio between <code>PyQTorch</code> (numerator) and <code>Horqrux</code> (denominator) executions is computed. A ratio higher than \\(1\\) means <code>Horqrux</code> and jitting provide computational speed-up over <code>PyQTorch</code>.</p> <pre><code>frame_vqe = pd.concat([frame_vqe, frame_vqeshots], ignore_index=True)\n\npyq_vqe = frame_vqe[frame_vqe.name == 'pyq'][['fn_circuit', 'median', 'n_shots', 'diff_mode']]\nhorqrux_vqe = frame_vqe[frame_vqe.name == 'horqrux'][['fn_circuit', 'median', 'n_shots', 'diff_mode']]\nratio_df = pd.merge(pyq_vqe, horqrux_vqe, on=['fn_circuit', 'diff_mode', 'n_shots'], suffixes=['_pyq', '_horqrux'])\nratio_df['ratio'] = ratio_df['median_pyq'] / ratio_df['median_horqrux']\naxes = ratio_df[ratio_df.n_shots == 0].boxplot('ratio', by=['fn_circuit', 'diff_mode'])\naxes.set_title('Speedup distributions by circuit without shots - 50 epochs')\naxes.set_xlabel('')\naxes.set_ylabel('Speedup')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n\n\naxes = ratio_df[ratio_df.n_shots &gt; 0].boxplot('ratio', by='fn_circuit')\naxes.set_title('Speedup distributions by circuit with shots - 10 epochs')\naxes.set_xlabel('')\naxes.set_ylabel('Speedup')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-05-08T10:03:53.964243 image/svg+xml Matplotlib v3.10.1, https://matplotlib.org/ 2025-05-08T10:03:54.055188 image/svg+xml Matplotlib v3.10.1, https://matplotlib.org/ <ol> <li> <p>Tyson Jones, Julien Gacon, Efficient calculation of gradients in classical simulations of variational quantum algorithms (2020) \u21a9\u21a9</p> </li> <li> <p>Tilly et al., The Variational Quantum Eigensolver: a review of methods and best practices (2022) \u21a9</p> </li> <li> <p>Pennylane, Quantum Datasets \u21a9</p> </li> </ol>"}]}