{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>Aquordion</code>","text":"<p><code>Aquordion</code> is a library to test and benchmark Pasqal's backends.</p>"},{"location":"#cross-backend-testing","title":"Cross-backend testing","text":"<p>Run the following to check correctness between backends:</p> <pre><code>hatch -e tests run test\n</code></pre>"},{"location":"#timing-benchmarks","title":"Timing benchmarks","text":"<p>Run the following command to generate timings:</p> <pre><code>hatch -e tests run benchmarks\n</code></pre>"},{"location":"benchmarks/","title":"Stats","text":"<p>We generate timing statistics using <code>pytest-benchmark</code> using \\(R\\) rounds for circuits A, B, C <sup>1</sup>. So far, we benchmark between <code>PyQTorch</code> and <code>Horqrux</code>:</p> <ul> <li>the <code>run</code> method,</li> <li>the <code>expectation</code> method using a single observable Z,</li> <li>a variational quantum eigensolver<sup>2</sup> (VQE) for the \\(H2\\) molecule in the STO-3G basis with a bondlength of \\(0.742 \\mathring{A}\\)<sup>3</sup>. The underlying gradient-based Adam optimizer is run for \\(50\\) iterations.</li> </ul> <p>The current execution times (with \\(R=10\\)) are for circuits defined over \\(2, 5, 10, 15\\) qubits and \\(2, 5\\) layers for the <code>run</code> and <code>expectation</code> methods. For VQE, we reduce the tests to only \\(10\\) qubits for avoiding long jobs time on Github and \\(R=5\\).</p> <pre><code>import json\nimport pandas as pd\nimport re\nimport matplotlib.pyplot as plt\n\nimport os.path\nfname = \"stats.json\"\nif not os.path.isfile(fname):\n    fname = \"docs/stats.json\"\nwith open(fname, 'r') as f:\n    data= json.load(f)['benchmarks']\n\ndata_stats = [{'name': x['name']} | x['params'] | x['stats'] for x in data]\n\nframe = pd.DataFrame(data_stats)\nframe['name'] = frame['name'].apply(lambda x: re.findall('test_(.*)\\\\[', x)[0])\nframe['fn_circuit'] = frame['benchmark_circuit'].apply(str)\nframe['fn_circuit'] = frame['fn_circuit'].apply(lambda x: re.findall('function (.*) at', x)[0])\n</code></pre>"},{"location":"benchmarks/#run-method","title":"Run method","text":"<p>Here are the median execution times for the <code>run</code> method over a random state.</p> <pre><code>run_frame = frame[frame['name'].str.startswith('run')]\nrun_frame['name'] = run_frame['name'].str.replace('run_', '')\n\naxes = run_frame.boxplot('median', by=['fn_circuit', 'name'])\naxes.set_title('Timing distributions by test and circuit')\naxes.set_xlabel('')\naxes.set_ylabel('Time (s)')\naxes.set_yscale('log')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-04-24T16:24:46.643424 image/svg+xml Matplotlib v3.10.1, https://matplotlib.org/"},{"location":"benchmarks/#expectation-method-z0-observable","title":"Expectation method: Z(0) observable","text":"<p>Here are the median execution times for the <code>expectation</code> method over a random state and the \\(Z(0)\\) observable.</p> <pre><code>expectation_frame = frame[frame['name'].str.startswith('expectation')]\nexpectation_frame['name'] = expectation_frame['name'].str.replace('expectation_', '')\naxes = expectation_frame.boxplot('median', by=['fn_circuit', 'name'])\naxes.set_title('Timing distributions by test and circuit')\naxes.set_xlabel('')\naxes.set_ylabel('Time (s)')\naxes.set_yscale('log')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-04-24T16:24:46.863519 image/svg+xml Matplotlib v3.10.1, https://matplotlib.org/"},{"location":"benchmarks/#vqe","title":"VQE","text":"<p>Here are the median execution times for VQE. We compare optimizing with <code>PyQTorch</code> against optimizing with <code>Horqrux</code> and jitting.</p>"},{"location":"benchmarks/#times","title":"Times","text":"<p>Below we present the distribution of median times for each circuit type.</p> <pre><code>fname = \"stats_vqe.json\"\nif not os.path.isfile(fname):\n    fname = \"docs/stats_vqe.json\"\nwith open(fname, 'r') as f:\n    data_vqe = json.load(f)['benchmarks']\n\ndata_stats_vqe = [{'name': x['name']} | x['params'] | x['stats'] for x in data_vqe]\n\nframe_vqe = pd.DataFrame(data_stats_vqe)\nframe_vqe['name'] = frame_vqe['name'].apply(lambda x: re.findall('test_(.*)\\\\[', x)[0])\nframe_vqe['fn_circuit'] = frame_vqe['benchmark_vqe_ansatz'].apply(str)\nframe_vqe['fn_circuit'] = frame_vqe['fn_circuit'].apply(lambda x: re.findall('function (.*) at', x)[0])\nframe_vqe['name'] = frame_vqe['name'].str.replace('vqe_', '')\naxes = frame_vqe.boxplot('median', by=['fn_circuit', 'name'])\naxes.set_title('Timing distributions by test and circuit')\naxes.set_xlabel('')\naxes.set_ylabel('Time (s)')\naxes.set_yscale('log')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-04-24T16:24:47.079906 image/svg+xml Matplotlib v3.10.1, https://matplotlib.org/"},{"location":"benchmarks/#speed-ups","title":"Speed-ups","text":"<p>Below we present the distribution of median speed-ups for each circuit type. The timing ratio between <code>PyQTorch</code> (numerator) and <code>Horqrux</code> (denominator) executions is computed. A ratio higher than \\(1\\) means <code>Horqrux</code> and jitting provide computational speed-up over <code>PyQTorch</code>.</p> <pre><code>pyq_vqe = frame_vqe[frame_vqe.name == 'pyq'][['fn_circuit', 'median']]\nhorqrux_vqe = frame_vqe[frame_vqe.name == 'horqrux'][['fn_circuit', 'median']]\nratio_df = pd.merge(pyq_vqe, horqrux_vqe, on='fn_circuit', suffixes=['_pyq', '_horqrux'])\nratio_df['ratio'] = ratio_df['median_pyq'] / ratio_df['median_horqrux']\naxes = ratio_df.boxplot('ratio', by='fn_circuit')\naxes.set_title('Speedup distributions by circuit')\naxes.set_xlabel('')\naxes.set_ylabel('Speedup')\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-04-24T16:24:47.211575 image/svg+xml Matplotlib v3.10.1, https://matplotlib.org/ <ol> <li> <p>Tyson Jones, Julien Gacon, Efficient calculation of gradients in classical simulations of variational quantum algorithms (2020) \u21a9</p> </li> <li> <p>Tilly et al., The Variational Quantum Eigensolver: a review of methods and best practices (2022) \u21a9</p> </li> <li> <p>Pennylane, Quantum Datasets \u21a9</p> </li> </ol>"}]}