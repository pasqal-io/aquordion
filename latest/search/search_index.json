{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>Aquordion</code>","text":"<p><code>Aquordion</code> is a library to test and benchmark Pasqal's backends.</p>"},{"location":"#cross-backend-testing","title":"Cross-backend testing","text":"<p>Run the following to check correctness between backends:</p> <pre><code>hatch -e tests run test\n</code></pre>"},{"location":"#timing-benchmarks","title":"Timing benchmarks","text":"<p>Run the following command to generate timings:</p> <pre><code>hatch -e tests run benchmarks\n</code></pre>"},{"location":"benchmarks/","title":"Stats","text":"<p>We generate time stats using <code>pytest-benchmark</code> using \\(10\\) rounds for circuits A, B, C coming from  [^1]. The current execution times are for circuits defined over \\(2, 5, 10, 15\\) qubits and \\(2, 5\\) layers. So far, we benchmark between <code>PyQTorch</code> and <code>Horqrux</code> the <code>run</code> and <code>expectation</code> methods.</p> <pre><code>import json\nimport pandas as pd\nimport re\nimport matplotlib.pyplot as plt\n\nimport os.path\nfname = \"stats.json\"\nif not os.path.isfile(fname):\n    fname = \"docs/stats.json\"\nwith open(fname, 'r') as f:\n    data= json.load(f)['benchmarks']\n\ndata_stats = [{'name': x['name']} | x['params'] | x['stats'] for x in data]\n\nframe = pd.DataFrame(data_stats)\nframe['name'] = frame['name'].apply(lambda x: re.findall('test_(.*)\\\\[', x)[0])\nframe['fn_circuit'] = frame['benchmark_circuit'].apply(str)\nframe['fn_circuit'] = frame['fn_circuit'].apply(lambda x: re.findall('function (.*) at', x)[0])\n</code></pre>"},{"location":"benchmarks/#run-method","title":"Run method","text":"<p>Here are the median execution times for the <code>run</code> method over a random state.</p> <pre><code>run_frame = frame[frame['name'].str.startswith('run')]\nrun_frame['name'] = run_frame['name'].str.replace('run_', '')\n\naxes = run_frame.boxplot('median', by=['fn_circuit', 'name'])\naxes.set_title('Timing distributions by test and circuit')\naxes.set_xlabel('')\naxes.set_ylabel('Time (s)')\naxes.set_yscale('log')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-04-10T08:43:28.488428 image/svg+xml Matplotlib v3.10.1, https://matplotlib.org/"},{"location":"benchmarks/#expectation-method-z0-observable","title":"Expectation method: Z(0) observable","text":"<p>Here are the median execution times for the <code>expectation</code> method over a random state and the \\(Z(0)\\) observable.</p> <pre><code>expectation_frame = frame[frame['name'].str.startswith('expectation')]\nexpectation_frame['name'] = expectation_frame['name'].str.replace('expectation_', '')\naxes = expectation_frame.boxplot('median', by=['fn_circuit', 'name'])\naxes.set_title('Timing distributions by test and circuit')\naxes.set_xlabel('')\naxes.set_ylabel('Time (s)')\naxes.set_yscale('log')\nplt.xticks(rotation=75)\nplt.suptitle('')\nplt.tight_layout()\n</code></pre> 2025-04-10T08:43:28.704932 image/svg+xml Matplotlib v3.10.1, https://matplotlib.org/ <p>[^1]: Tyson Jones, Julien Gacon, Efficient calculation of gradients in classical simulations of variational quantum algorithms (2020)</p>"}]}